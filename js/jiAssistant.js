/*
*  copyright 2012 James Ingram
*  http://james-ingram-act-two.de/
*
*  Code licensed under MIT
*  https://github.com/notator/assistant-performer/blob/master/License.md
*
*  jiAssistant.js
*  The JI_NAMESPACE.assistant namespace which defines the
*    Assistant() constructor. 
*/

/*jslint bitwise: true, nomen: false, plusplus: true, white: true */

JI_NAMESPACE.namespace('JI_NAMESPACE.assistant');

JI_NAMESPACE.assistant = (function (window)
{
    "use strict";
    // begin var
    var
    CMD = MIDILib.constants.COMMAND,
    Message = MIDILib.message.Message,
    Moment = MIDILib.moment.Moment,
    getInputEvent = MIDILib.message.getInputEvent,
    Sequence = MIDILib.sequence.Sequence,

    outputDevice,
    trackIsOnArray,

    // Assistant's midi input message types
    UNKNOWN = 0,
    ILLEGAL_INDEX = 1,
    END_OF_SEQUENCE = 2,
    CHANNEL_PRESSURE = 3, // generated by my E-MU keyboard, when "Aftertouch" is switched on.
    AFTERTOUCH = 4, // from EWI breath controller
    MODULATION_WHEEL = 5, // from EWI bite controller or E-MU modulation wheel
    PITCH_WHEEL = 6, // from EWI pitch bend controllers or E-MU pitch wheel
    NOTE_ON = 7,
    NOTE_OFF = 8,

    options, // performance options. This is the options object in jiAPControls. 
    reportEndOfPerformance, // callback
    recordingSequence, // initially set by assistant.playSpan(...), passed repeatedly to sequence.playSpan(...), returned by reportEndOfPerformance()
    reportMsPosition, // callback

    // An array of Sequence containing one sequence for each chord or rest
    // symbol in the whole live performer's track (except that the sequences
    // in consecutive rests have been concatenated to one sequence).
    allSequences,

    // An array containing only the sequences which are to be performed.
    // This array is constructed in playSpan() from allSequences, using
    // fromMsPositionInScore and toMsPositionInScore.
    // The first sequence in performedSequences may be the second part
    // of a sequence which has been split at fromMsPositionInScore.
    // The last sequence in performedSequences may be the first part
    // of a sequence which has been split at toMsPositionInScore.
    performedSequences,

    // these variables are initialized by playSpan() and used by handleMIDIInputEvent() 
    endIndex = -1,
    currentIndex = -1, // the index of the currently playing sequence (which will be stopped when a noteOn or noteOff arrives).
    nextIndex = 0, // the index of the sequence which will be played when a noteOn evt arrives
    performanceStartNow, // set when the first sequence starts, used to set the reported duration of the performance 
    sequenceStartNow, // set when a sequence starts playing, used in the relative durations option 
    prevSequenceStartNow = 0.0, // used only with the relative durations option
    pausedNow = 0.0, // used only with the relative durations option (the time at which the sequence was paused).

    stopped = true,
    paused = false,

    currentLivePerformersKeyPitch = -1, // -1 means "no key depressed". This value is set when the live performer sends a noteOff

    forwardSetState, // forward declaration, set to setState later.

    stop = function ()
    {
        var nSequences, performanceMsDuration;

        if (stopped === false)
        {
            nSequences = performedSequences.length;

            forwardSetState("stopped");

            performanceMsDuration = window.performance.now() - performanceStartNow;

            reportEndOfPerformance(recordingSequence, performanceMsDuration);
        }
    },

    // If options.assistedPerformance === true, this is where input
    // MIDIEvents arrive, and where processing is going to be done.
    handleMIDIInputEvent = function (data)
    {
        var inputEvent, inputEventType, command, cmd;

        function inputCommand(inputEvent)
        {
            return (inputEvent.data[0] & 0xF0) >> 8;
        }

        function inputChannel(inputEvent)
        {
            return (inputEvent.data[0] & 0xF);
        }

        function inputData1(inputEvent)
        {
            return inputEvent.data[1];
        }

        function inputData2(inputEvent)
        {
            return inputEvent.data[2];
        }

        function inputEventToString(inputEvent)
        {
            var
            command = inputCommand(inputEvent),
            channel = inputChannel(inputEvent),
            data1 = inputData1(inputEvent),
            data2 = inputData2(inputEvent),
            receivedTime = inputEvent.receivedTime;

            return "Input message: command:".concat(command).concat(", channel:").concat(channel).concat(", data1:").concat(data1).concat(", data2:").concat(data2).concat(", receivedTime:").concat(receivedTime);
        }

        // getInputEventType returns one of the following constants:
        // UNKNOWN = 0, ILLEGAL_INDEX = 1, END_OF_SEQUENCE = 2, CHANNEL_PRESSURE = 3, AFTERTOUCH = 4,
        // MODULATION_WHEEL = 5, PITCH_WHEEL = 6, NOTE_ON = 7, NOTE_OFF = 8
        function getInputEventType(command)
        {
            var
            type = UNKNOWN;

            switch (command)
            {
                case 0x80:
                    type = NOTE_OFF;
                    break;
                case 0x90:
                    if (inputData2(inputEvent) === 0) // velocity 0
                    {
                        type = NOTE_OFF;
                    }
                    else
                    {
                        type = NOTE_ON;
                    }
                    break;
                case 0xA0:
                    // generated by EWI controller
                    type = AFTERTOUCH;
                    break;
                case 0xB0:
                    if (inputData1(inputEvent) === 1)
                    {
                        type = MODULATION_WHEEL;
                    }
                    break;
                case 0xD0:
                    // This type is generated by my E-MU keyboard when "Aftertouch" is switched on.
                    type = CHANNEL_PRESSURE;
                    break;
                case 0xE0:
                    type = PITCH_WHEEL;
                    break;
                default:
                    type = UNKNOWN;
                    break;
            }

            return type;
        }

        function handleController(controlData, value, usesSoloTrack, usesOtherTracks)
        {
            var i, moment, messages, nMessages, j,
                livePerformersTrackIndex = options.livePerformersTrackIndex,
                nTracks = allSequences[0].tracks.length,
                now = window.performance.now(),
                channelMoments;

            // Returns an array of synchronous moments, one moment per channel,
            // The moment.messages are the controller messages for the appropriate channels.
            function getChannelMoments(nTracks, controlData, value, usesSoloTrack, usesOtherTracks)
            {
                var i, channelMoments = [];

                // channel is the new message's channel
                // value is the new message's value
                function newControlMessage(controlData, channel, value)
                {
                    var message, d;

                    if (controlData.midiControl !== undefined)
                    {
                        // a normal control
                        message = new Message(CMD.CONTROL_CHANGE + channel, controlData.midiControl, value, 0);
                    }
                    else if (controlData.statusHighNibble !== undefined)
                    {
                        // pitch-bend or channel pressure
                        if (controlData.statusHighNibble === CMD.PITCH_WHEEL)
                        {
                            d = MIDILib.message.to14Bit(value);
                            message = new Message(CMD.PITCH_WHEEL + channel, d.data1, d.data2, 0);
                        }
                        else if (controlData.statusHighNibble === CMD.CHANNEL_AFTERTOUCH)
                        {
                            message = new Message(CMD.CHANNEL_AFTERTOUCH + channel, value, 0, 0);
                        }
                        else
                        {
                            throw "Illegal controlData.";
                        }
                    }
                    else
                    {
                        throw "Illegal controlData.";
                    }

                    return message;
                }

                for (i = 0; i < nTracks; ++i)
                {
                    moment = new Moment(MIDILib.moment.UNDEFINED_TIMESTAMP);  // moment.msPositionInScore becomes UNDEFINED_TIMESTAMP
                    channelMoments.push(moment);
                }

                if (usesSoloTrack && usesOtherTracks)
                {
                    for (i = 0; i < nTracks; ++i)
                    {
                        if (trackIsOnArray[i])
                        {
                            channelMoments[i].messages.push(newControlMessage(controlData, i, value));
                        }
                    }
                }
                else if (usesSoloTrack)
                {
                    channelMoments[livePerformersTrackIndex].messages.push(newControlMessage(controlData, livePerformersTrackIndex, value));
                }
                else if (usesOtherTracks)
                {
                    for (i = 0; i < nTracks; ++i)
                    {
                        if (trackIsOnArray[i] && i !== livePerformersTrackIndex)
                        {
                            channelMoments[i].messages.push(newControlMessage(controlData, i, value));
                        }
                    }
                }
                else
                {
                    throw "Either usesSoloTrack or usesOtherTracks must be set here.";
                }
                
                return channelMoments;
            }

            channelMoments = getChannelMoments(nTracks, controlData, value, usesSoloTrack, usesOtherTracks);

            for (i = 0; i < nTracks; ++i)
            {
                moment = channelMoments[i];
                moment.timestamp = now;
                messages = moment.messages;
                nMessages = messages.length;
                if (nMessages > 0 && recordingSequence !== undefined && recordingSequence !== null)
                {
                    // Note that the score is currently being played back, and is also
                    // writing to this recording sequence. This should not cause a problem
                    // because this call to addTimestampedMoment() should happen while
                    // sequence.tick() is waiting for setTimeout() to return.
                    // If there's a problem after all, I may have to implement locking
                    // on the sequence when adding timestamped moments -- or add new
                    // messages to the final moment in the track if the new moment.timestamp
                    // is less than the final moment's timestamp.
                    recordingSequence.tracks[i].addTimestampedMoment(moment);
                }
                for (j = 0; j < nMessages; ++j)
                {
                    outputDevice.send(messages[j].data, now);
                }
            }
        }

        function silentlyCompleteCurrentlyPlayingSequence()
        {
            // currentIndex is the index of the currently playing sequence
            // (which should be silently completed when a noteOn arrives).
            if (currentIndex >= 0 && currentIndex < performedSequences.length)
            {
                performedSequences[currentIndex].finishSilently();
            }
        }

        // Each performedSequence calls this function (with two arguments) when
        // it stops:
        //      reportEndOfSequence(recordingSequence, performanceMsDuration);
        // but those arguments are ignored here. The recording continues until
        // the end of the performance, and performanceMsDuration is the duration
        // set by the beginning of the following performedSequence.
        // These values are passed back to the calling environment, when the
        // assistant stops, using the callback:
        //      reportEndOfPerformance(recordingSequence, performanceMsDuration);
        function reportEndOfSequence()
        {
            if (currentLivePerformersKeyPitch === -1) // key is up
            {
                if (currentIndex === endIndex)
                {
                    stop();
                }
                else if (performedSequences[nextIndex].chordSequence !== undefined)
                {
                    reportMsPosition(performedSequences[nextIndex].msPositionInScore);
                }
            }
            else if (nextIndex <= endIndex && performedSequences[nextIndex].restSequence !== undefined)
            {
                reportMsPosition(performedSequences[nextIndex].msPositionInScore);
            }
            // else wait for noteOff message (see handleNoteOff below).
        }

        function playSequence(sequence, options)
        {
            var
            prevSequenceScoreMsDuration,
            durationFactor;

            // Moment adjustedTimeReSequence attributes are set (relative to the start of the
            // sequence), using sequence.msPositionInScore, moment.msPositionInScore and
            // the durationFactor.
            // The msPositionInScore of each message's containing moment is unchanged.
            function setMomentTimestamps (sequence, durationFactor)
            {
                var
                sequenceMsPosition = sequence.msPositionInScore,
                nTracks = sequence.tracks.length, moment,
                i, j, track, trackLength;

                for (i = 0; i < nTracks; ++i)
                {
                    track = sequence.tracks[i];
                    trackLength = track.moments.length;
                    for (j = 0; j < trackLength; ++j)
                    {
                        moment = track.moments[j];
                        moment.adjustedTimeReSequence = Math.floor((moment.msPositionInScore - sequenceMsPosition) * durationFactor);
                    }
                }
            }

            if (options.assistantUsesAbsoluteDurations === false)
            {
                if (currentIndex > 0)
                {
                    prevSequenceScoreMsDuration = performedSequences[currentIndex].msPositionInScore - performedSequences[currentIndex - 1].msPositionInScore;
                    durationFactor = (sequenceStartNow - prevSequenceStartNow) / prevSequenceScoreMsDuration;

                    console.log("currentIndex=" + currentIndex.toString() + " durationFactor=" + durationFactor.toString());

                    // durations in the sequence are multiplied by durationFactor
                    setMomentTimestamps(sequence, durationFactor);
                }
                prevSequenceStartNow = sequenceStartNow; // used only with the relative durations option
            }

            // if options.assistantUsesAbsoluteDurations === true, the durations are related to msPositionInScore
            // else the durations will be related to moment.timestamps which have been set relative to the start of the sequence.
            sequence.playSpan(outputDevice, 0, Number.MAX_VALUE, trackIsOnArray, recordingSequence, reportEndOfSequence, reportMsPosition);
        }

        function handleNoteOff(inputEvent)
        {
            //console.log("NoteOff, pitch:", inputData1(inputEvent).toString(), " velocity:", inputEvent.data2.toString());

            if (inputData1(inputEvent) === currentLivePerformersKeyPitch)
            {
                currentLivePerformersKeyPitch = -1;

                silentlyCompleteCurrentlyPlayingSequence();

                if (currentIndex === endIndex) // see reportEndOfPerformance() above 
                {
                    stop();
                }
                else if (performedSequences[nextIndex].restSequence !== undefined) // only play the next sequence if it is a restSequence
                {
                    currentIndex = nextIndex++;
                    sequenceStartNow = inputEvent.receivedTime;
                    playSequence(performedSequences[currentIndex], options);
                }
                else if (nextIndex <= endIndex)
                {
                    reportMsPosition(performedSequences[nextIndex].msPositionInScore);
                }
            }
        }

        function handleNoteOn(inputEvent, overrideSoloPitch, overrideOtherTracksPitch, overrideSoloVelocity, overrideOtherTracksVelocity)
        {
            var sequence;

            // Shifts the pitches in the whole performer's track up or down so that the lowest pitch in the
            // first noteOn moment is newPitch. Similarly with velocity.
            function overridePitchAndOrVelocity (sequence, soloTrackIndex, newPitch, newVelocity,
                overrideSoloPitch, overrideOtherTracksPitch, overrideSoloVelocity, overrideOtherTracksVelocity)
            {
                var
                NOTE_ON_CMD = CMD.NOTE_ON,
                track = sequence.tracks[soloTrackIndex], message, lowestNoteOnEvt, pitchDelta, velocityDelta;

                // Returns the lowest NoteOn message in the first moment in the track to contain a NoteOnMessage.
                // Returns null if there is no such message.
                function findLowestNoteOnEvt(NOTE_ON_CMD, track)
                {
                    var i, j, message, moment, nEvents, nMoments = track.moments.length, lowestNoteOnMessage = null;

                    for (i = 0; i < nMoments; ++i)
                    {
                        moment = track.moments[i];
                        nEvents = moment.messages.length;
                        for (j = 0; j < nEvents; ++j)
                        {
                            message = moment.messages[j];
                            if ((message.command() === NOTE_ON_CMD)
                            && (lowestNoteOnMessage === null || message.data[1] < lowestNoteOnMessage.data1))
                            {
                                lowestNoteOnMessage = message;
                            }
                        }
                        if (lowestNoteOnMessage !== null)
                        {
                            break;
                        }
                    }
                    return lowestNoteOnMessage;
                }

                function midiValue(value)
                {
                    var result = (value >= 0) ? value : 0;
                    result = (value <= 127) ? value : 127;
                    return result;
                }

                function adjustTracks(NOTE_ON_CMD, soloTrackIndex, pitchDelta, velocityDelta,
                    overrideSoloPitch, overrideOtherTracksPitch, overrideSoloVelocity, overrideOtherTracksVelocity)
                {
                    var nTracks = sequence.tracks.length, i, j, k, nMoments, moment, nEvents;

                    for (i = 0; i < nTracks; ++i)
                    {
                        if ((i === soloTrackIndex && (overrideSoloPitch || overrideSoloVelocity))
                        || (i !== soloTrackIndex && (overrideOtherTracksPitch || overrideOtherTracksVelocity)))
                        {
                            track = sequence.tracks[i];
                            nMoments = track.moments.length;

                            for (j = 0; j < nMoments; ++j)
                            {
                                moment = track.moments[j];
                                nEvents = moment.messages.length;
                                for (k = 0; k < nEvents; ++k)
                                {
                                    message = moment.messages[k];
                                    if (message.command() === NOTE_ON_CMD)
                                    {
                                        message.data[1] = midiValue(message.data[1] + pitchDelta);
                                        message.data[2] = midiValue(message.data[2] + velocityDelta);
                                    }
                                }
                            }
                        }
                    }
                }

                lowestNoteOnEvt = findLowestNoteOnEvt(NOTE_ON_CMD, track);
                if (lowestNoteOnEvt !== null)
                {
                    pitchDelta = (overrideSoloPitch || overrideOtherTracksPitch) ? (newPitch - lowestNoteOnEvt.data1) : 0;
                    velocityDelta = (overrideSoloVelocity || overrideOtherTracksVelocity) ? (newVelocity - lowestNoteOnEvt.data2) : 0;

                    if (pitchDelta !== 0 || velocityDelta !== 0)
                    {
                        adjustTracks(NOTE_ON_CMD, soloTrackIndex, pitchDelta, velocityDelta,
                            overrideSoloPitch, overrideOtherTracksPitch, overrideSoloVelocity, overrideOtherTracksVelocity);
                    }
                }
            }

            //console.log("NoteOn, pitch:", inputData1(inputEvent).toString(), " velocity:", inputData2(inputEvent).toString());

            sequenceStartNow = inputEvent.receivedTime;

            currentLivePerformersKeyPitch = inputData1(inputEvent);

            if (inputData2(inputEvent) > 0)
            {
                silentlyCompleteCurrentlyPlayingSequence();

                if (nextIndex === 0)
                {
                    performanceStartNow = sequenceStartNow;
                }

                if (nextIndex === 0 || (nextIndex <= endIndex && performedSequences[nextIndex].chordSequence !== undefined))
                {
                    currentIndex = nextIndex++;
                    sequence = performedSequences[currentIndex];
                    if (overrideSoloPitch || overrideOtherTracksPitch || overrideSoloVelocity || overrideOtherTracksVelocity)
                    {
                        overridePitchAndOrVelocity(sequence, options.livePerformersTrackIndex,
                            inputData1(inputEvent), inputData2(inputEvent),
                            overrideSoloPitch, overrideOtherTracksPitch, overrideSoloVelocity, overrideOtherTracksVelocity);
                    }
                    playSequence(sequence, options);
                }
            }
            else // velocity 0 is "noteOff"
            {
                handleNoteOff(inputEvent);
            }
        }

        inputEvent = getInputEvent(data, window.performance.now());

        inputEventType = getInputEventType(data[0] & 0xF0);

        switch (inputEventType)
        {
            case CHANNEL_PRESSURE: // EMU "aftertouch"
                console.log("Channel (=key) Pressure, value:", inputData1(inputEvent).toString());
                if (options.pressureSubstituteControlData !== null)
                {
                    handleController(options.pressureSubstituteControlData, inputData1(inputEvent), // ACHTUNG! data1 is correct!
                                                options.usesPressureSolo, options.usesPressureOtherTracks);
                }
                break;
            case AFTERTOUCH: // EWI breath controller
                console.log("Aftertouch, value:", inputData2(inputEvent).toString());
                if (options.pressureSubstituteControlData !== null)
                {
                    handleController(options.pressureSubstituteControlData, inputData2(inputEvent),
                                                options.usesPressureSolo, options.usesPressureOtherTracks);
                }
                break;
            case MODULATION_WHEEL: // EWI bite, EMU modulation wheel
                console.log("Modulation Wheel, value:", inputData2(inputEvent).toString());
                if (options.modSubstituteControlData !== null)
                {
                    handleController(options.modSubstituteControlData, inputData2(inputEvent),
                                                options.usesModSolo, options.usesModOtherTracks);
                }
                break;
            case PITCH_WHEEL: // EWI pitch bend up/down controllers, EMU pitch wheel
                console.log("Pitch Wheel, value:", inputData2(inputEvent).toString());
                if (options.pitchBendSubstituteControlData !== null)
                {
                    handleController(options.pitchBendSubstituteControlData, inputData2(inputEvent),
                                                options.usesPitchBendSolo, options.usesPitchBendOtherTracks);
                }
                break;
            case NOTE_ON:
                handleNoteOn(inputEvent,
                    options.overrideSoloPitch, options.overrideOtherTracksPitch,
                    options.overrideSoloVelocity, options.overrideOtherTracksVelocity);
                break;
            case NOTE_OFF:
                handleNoteOff(inputEvent);
                break;
            case END_OF_SEQUENCE:
                stop();
                break;
            case UNKNOWN:
                // This might be program change (0xC0 = 192) or system exclusive (0xF0 = 240),
                // neither of which I'm currently expecting in the input.
                command = inputCommand(inputEvent);
                cmd = null;
                if (command === 0xC0)
                {
                    cmd = "PROGRAM CHANGE";
                }
                else
                {
                    cmd = "SYSTEM EXCLUSIVE";
                }
                if (cmd !== null)
                {
                    throw "Unexpected " + cmd + " command in input";
                }
                else
                {
                    throw "Error: Unexpected controller message ".concat(inputEventToString(inputEvent));
                }
            case ILLEGAL_INDEX:
                throw "illegal index";
        }
    },

    setState = function (state)
    {
        function closeInputDevice(options)
        {
             if (options.inputDevice !== undefined && options.inputDevice !== null)
             {
                 options.inputDevice.close();
             }
        }

        switch (state)
        {
            case "stopped":
                if (currentIndex >= 0 && performedSequences[currentIndex].isStopped() === false)
                {
                    performedSequences[currentIndex].stop();
                }
                // these variables are also set in playSpan() when the state is first set to "running"
                endIndex = (performedSequences === undefined) ? -1 : (performedSequences.length - 1); // the index of the (unplayed) end chord or rest or endBarline
                currentIndex = -1;
                nextIndex = 0;
                prevSequenceStartNow = 0.0; // used only with the relative durations option
                pausedNow = 0.0; // used only with the relative durations option (the time at which the sequence was paused).
                stopped = true;
                paused = false;
                closeInputDevice(options);
                break;
            case "paused":
                stopped = false;
                paused = true;
                closeInputDevice(options);
                break;
            case "running":
                stopped = false;
                paused = false;
                options.getInputDevice(handleMIDIInputEvent);
                break;
            default:
                throw "Unknown sequencer state!";
        }
    },

    // Can only be called when paused is true.
    resume = function ()
    {
        if (paused === true)
        {
            if (options.assistantUsesAbsoluteDurations === false)
            {
                sequenceStartNow = window.performance.now();
                prevSequenceStartNow += (sequenceStartNow - pausedNow);
            }
            performedSequences[currentIndex].resume();
            setState("running");
        }
    },

    // Can only be called while running
    // (stopped === false && paused === false)
    pause = function ()
    {
        if (stopped === false && paused === false)
        {
            pausedNow = window.performance.now();

            performedSequences[currentIndex].pause();
            setState("paused");
        }
        else
        {
            throw "Attempt to pause a stopped or paused sequence.";
        }
    },

    isStopped = function ()
    {
        return stopped === true;
    },

    isPaused = function ()
    {
        return paused === true;
    },

    // This function is called when options.assistedPerformance === true and the Go button is clicked (in the performance controls).
    // If options.assistedPerformance === false, the main sequence.playSpan(...) is called instead.
    // The assistant's allSequences array contains the whole piece as an array of sequence, with one sequence per performer's
    // rest or chord, whereby consecutive rests in the performer's track have been merged.
    // This function first constructs a performedSequences, which is the section of the allSequences array between fromMsPositionInScore and toMsPositionInScore.
    // Creating the performedSequences does *not* change the data in allSequences. The start and end markers can therefore be moved between
    // performances
    playSpan = function (outDevice, fromMsPositionInScore, toMsPositionInScore, argTrackIsOnArray, recordingSeq)
    {
        function getPerformedSequences(allSequences, fromMsPositionInScore, toMsPositionInScore)
        {
            var nSequences = allSequences.length,
                i = nSequences - 1,
                maxIndex = i, lastSequence,
                sequence = null,
                performedSequences = []; // an array of sequences

            // returns the portion of sequence before toMsPositionInScore
            // to which a "finalBarline" moment has been added.
            function newRestSequenceBeforeMsPos(sequence, toMsPositionInScore)
            {
                var
                i, newTrack, oldTrack, nTracks = sequence.tracks.length,
                j, nMoments, restSequence;

                function appendFinalBarlineMoment(track, msPositionInScore)
                {
                    var finalBarlineMoment;

                    finalBarlineMoment = new MIDILib.moment.Moment(msPositionInScore);
                    Object.defineProperty(finalBarlineMoment, "restStart", { value: true, writable: false });

                    track.addMoment(finalBarlineMoment);
                }

                restSequence = new Sequence(nTracks);
                Object.defineProperty(restSequence, "restSequence", { value: true, writable: false });

                for (i = 0; i < nTracks; ++i)
                {
                    newTrack = restSequence.tracks[i];
                    oldTrack = sequence.tracks[i];
                    nMoments = oldTrack.moments.length;
                    for (j = 0; j < nMoments; ++j)
                    {
                        newTrack.moments.push(oldTrack.moments[j]);
                    }

                    appendFinalBarlineMoment(newTrack, toMsPositionInScore);
                }
                return restSequence;
            }

            // returns the portion of sequence beginning at fromMsPositionInScore
            // as a new rest sequence.
            function newRestSequenceAfterMsPos(sequence, fromMsPositionInScore)
            {
                var
                i, newTrack, oldTrack, nTracks = sequence.tracks.length,
                j, nMoments, k, restSequence;

                restSequence = new Sequence(nTracks);
                Object.defineProperty(restSequence, "restSequence", { value: true, writable: false });

                for (i = 0; i < nTracks; ++i)
                {
                    newTrack = restSequence.tracks[i];
                    oldTrack = sequence.tracks[i];
                    nMoments = oldTrack.moments.length;
                    for (j = 0; j < nMoments; ++j)
                    {
                        if (oldTrack.moments[j].msPositionInScore >= fromMsPositionInScore)
                        {
                            k = j;
                            break;
                        }
                    }
                    for (j = k; j < nMoments; ++j)
                    {
                        newTrack.moments.push(oldTrack.moments[j]);
                    }
                }
                return restSequence;
            }

            if (i > 0)
            {
                sequence = allSequences[i];
                while (i > 0 && sequence.msPositionInScore > fromMsPositionInScore)
                {
                    --i;
                    sequence = allSequences[i];
                }
            }

            // sequence.msPositionInScore <= fromMsPositionInScore
            if (sequence.restSequence !== undefined && sequence.msPositionInScore < fromMsPositionInScore)
            {
                sequence = newRestSequenceAfterMsPos(sequence, fromMsPositionInScore); // returns a new restSequence starting at fromMsPositionInScore
            }

            performedSequences.push(sequence); // the first sequence

            while (i < maxIndex)
            {
                ++i;
                sequence = allSequences[i];
                if (sequence.msPositionInScore >= toMsPositionInScore)
                {
                    break;
                }
                performedSequences.push(sequence);
            }

            lastSequence = performedSequences.pop();

            // lastSequence.msPositionInScore < toMsPositionInScore
            if (lastSequence.restSequence !== undefined)
            {
                // newRestSequenceBeforeMsPos() returns a new sequence which is
                // a copy of the beginning of lastSequence up to (but not including) toMsPositionInScore,
                // to which a "finalBarline" moment has been added.
                lastSequence = newRestSequenceBeforeMsPos(lastSequence, toMsPositionInScore);
            }

            //finalBarline = finalBarlineSequence(lastSequence.tracks.length, toMsPositionInScore);
            performedSequences.push(lastSequence);

            return performedSequences;
        }

        setState("running");
        outputDevice = outDevice;
        // trackIsOnArray is read only
        trackIsOnArray = argTrackIsOnArray;
        performedSequences = getPerformedSequences(allSequences, fromMsPositionInScore, toMsPositionInScore);
        recordingSequence = recordingSeq;

        endIndex = performedSequences.length - 1;
        currentIndex = -1;
        nextIndex = 0;
        prevSequenceStartNow = -1;
    },

    // creats an Assistant, complete with private sequences
    // called when the Start button is clicked, and options.assistedPerformance === true
    Assistant = function (sequence, apControlOptions, reportEndOfWholePerformance, reportMillisecondPosition)
    {
        // Returns an array of Sequence.
        // Each sequence in the array contains moments from the main sequence.
        // A sequence is first created for each chord or rest symbol and for the final barline in the live performer's track. 
        // Sequences corresponding to a live performer's chord are given a chordSequence attribute (=true).
        // Sequences corresponding to a live performer's rest are given a restSequence attribute (=true).
        // Consecutive restSequences are merged: When performing, consecutive rests in the performer's track are treated
        // as one. The live performer only starts the first one (with a noteOff). Following rests play automatically until
        // the next chord (chordSequence) in the performer's track.
        function getSequences(mainSequence, livePerformersTrackIndex)
        {
            var
            sequences = [],
            nTracks = sequence.tracks.length,
            trackIndex;

            // The returned empty sequences have been given an msPositionInScore attribute,
            // and either a restSequence or a chordSequence attribute, 
            // depending on whether they correspond to a live player's rest or chord.
            // They also contain the correct number of empty tracks.
            function getEmptySequences(nTracks, livePerformersTrack)
            {
                var s, emptySequences = [],
                    performersMidiMoments, nPerformersMidiMoments, i,
                    moment;

                performersMidiMoments = livePerformersTrack.moments;
                nPerformersMidiMoments = performersMidiMoments.length;
                for (i = 0; i < nPerformersMidiMoments; ++i)
                {
                    s = null;
                    moment = performersMidiMoments[i];

                    if (moment.restStart !== undefined)
                    {
                        s = new Sequence(nTracks);
                        Object.defineProperty(s, "restSequence", { value: true, writable: false });
                        Object.defineProperty(s, "msPositionInScore", { value: moment.msPositionInScore, writable: false });
                        //console.log("Rest Sequence: msPositionInScore=" + s.msPositionInScore.toString());
                    }
                    else if (moment.chordStart !== undefined)
                    {
                        s = new Sequence(nTracks);
                        Object.defineProperty(s, "chordSequence", { value: true, writable: false });
                        Object.defineProperty(s, "msPositionInScore", { value: moment.msPositionInScore, writable: false });
                        //console.log("Chord Sequence: msPositionInScore=" + s.msPositionInScore.toString());
                    }

                    if (s !== null)
                    {
                        emptySequences.push(s);
                    }
                }
                return emptySequences;
            }

            function fillSequences(sequences, mainSequence, trackIndex)  // 'base' function in outer scope.
            {
                var track, moments = mainSequence.tracks[trackIndex].moments,
                    moment, momentsIndex = 0,
                    nMidiMoments = moments.length,
                    sequence, sequencesIndex,
                    nSequences = sequences.length, // including the final barline
                    nextSequenceMsPositionInScore;

                function getNextSequenceMsPositionInScore(sequences, sequencesIndex, nSequences)
                {
                    var nextSequenceMsPositionInScore, nextIndex = sequencesIndex + 1;

                    if (nextIndex < nSequences)
                    {
                        nextSequenceMsPositionInScore = sequences[nextIndex].msPositionInScore;
                    }
                    else
                    {
                        nextSequenceMsPositionInScore = Number.MAX_VALUE;
                    }

                    return nextSequenceMsPositionInScore;
                }

                // nSequences includes the final barline (a restSequence which may contain noteOff messages).
                for (sequencesIndex = 0; sequencesIndex < nSequences; ++sequencesIndex)
                {
                    sequence = sequences[sequencesIndex];
                    nextSequenceMsPositionInScore = getNextSequenceMsPositionInScore(sequences, sequencesIndex, nSequences);
                    track = sequence.tracks[trackIndex];
                    // nMidiMoments may be 0 (an empty track)
                    if (nMidiMoments > 0 && momentsIndex < nMidiMoments)
                    {
                        moment = moments[momentsIndex];

                        while (moment.msPositionInScore < nextSequenceMsPositionInScore)
                        {
                            track.addMoment(moment);
                            ++momentsIndex;
                            if (momentsIndex === nMidiMoments)
                            {
                                break;
                            }
                            moment = moments[momentsIndex];
                        }
                    }
                }
            }

            // When performing, consecutive rests in the performer's track are treated as one.
            // The live performer only starts the first one (with a noteOff). Following rests
            // play automatically until the next chord in the performer's track.
            function mergeRestSequences(sequences)
            {
                var i, nSequences = sequences.length,
                newSequences = [], lastNewS,
                nTracks = sequences[0].tracks.length,
                sequence, t, currentTrack, trackToAppend, nMoments,
                iMom;

                newSequences.push(sequences[0]);

                for (i = 1; i < nSequences; ++i)
                {
                    lastNewS = newSequences[newSequences.length - 1];
                    if (lastNewS.restSequence !== undefined && sequences[i].restSequence !== undefined)
                    {
                        sequence = sequences[i];
                        // append sequence to lastnewS
                        for (t = 0; t < nTracks; ++t)
                        {
                            currentTrack = lastNewS.tracks[t];
                            trackToAppend = sequence.tracks[t];
                            nMoments = trackToAppend.moments.length;
                            for (iMom = 0; iMom < nMoments; ++iMom)
                            {
                                currentTrack.addMoment(trackToAppend.moments[iMom]);
                            }
                        }
                    }
                    else
                    {
                        newSequences.push(sequences[i]);
                    }
                }

                return newSequences;
            }

            sequences = getEmptySequences(nTracks, sequence.tracks[livePerformersTrackIndex]);

            for (trackIndex = 0; trackIndex < nTracks; ++trackIndex)
            {
                fillSequences(sequences, mainSequence, trackIndex);
                //fillSequences(sequences, sequence.tracks[trackIndex].moments);
            }

            sequences = mergeRestSequences(sequences);

            return sequences;
        }

        if (!(this instanceof Assistant))
        {
            return new Assistant(sequence, apControlOptions, reportEndOfWholePerformance, reportMillisecondPosition);
        }

        if (apControlOptions === undefined || apControlOptions.assistedPerformance !== true)
        {
            throw ("Error creating Assistant.");
        }

        options = apControlOptions;

        setState("stopped");

        reportEndOfPerformance = reportEndOfWholePerformance;
        reportMsPosition = reportMillisecondPosition;

        allSequences = getSequences(sequence, options.livePerformersTrackIndex);

        // Starts an assisted performance 
        this.playSpan = playSpan;

        // these are called by the performance controls
        this.pause = pause; // pause()        
        this.resume = resume; // resume()
        this.stop = stop; // stop()

        this.isStopped = isStopped; // isStopped()
        this.isPaused = isPaused; // isPaused()

        this.sequences = allSequences; // consulted by score when setting start and end marker positions.
    },

    publicAPI =
    {
        // empty Assistant constructor
        Assistant: Assistant
    };
    // end var

    forwardSetState = setState;

    return publicAPI;

}(window));
